# 兼容性的保证

一般而言，Java 程序是向下兼容的。这是因为 API 及其实现可以被看成是分离的两个部分。API 就像是一个窗口，用户知道它提供的服务种类，但是不知窗口背后是什么。通常，这可以归因于用户调用某个接口所规定的方法时不必知道其实现类。API 与其实现之间相互绑定，可能用到 Service Provider Interface 等等手段，此处不赘。总之，无论具体实现如何变动，只要旧有的类名、方法签名等不变，用户在多数情况下就不至于为找不到类、找不到方法等报错而困扰。

Bukkit 框架也遵循了这样的设计模式。在 Bukkit 文档里所能见的一切类，无论是否为接口，都是 API 的一部分，基本不会变动。Bukkit 框架通过设计使得其 API 的具体实现对用户不可见。比如 `org.bukkit.entity.Player` 是一个接口，在 Bukkit API 中没有某个方法的返回值类型是其实现类，也没有哪个方法以该接口的实现类作为参数。通过 `Bukkit#getPlayer` 方法获取到的对象是 `org.bukkit.entity.Player` 接口类型。把玩家当成参数的情况如 `Player#showPlayer` 等方法，也把 `org.bukkit.entity.Player` 作为参数的类型。因此在 Bukkit API 设计者所预想的情况下，`org.bukkit.entity.Player` 的实现类被隐藏了起来。只要有这个接口就可以完成 Bukkit API 内全部的玩家操作。这样，无论 `org.bukkit.entity.Player` 的实现类中的内容如何修改，只要接口所定义的方法不变、实现类实现了这些方法，向下兼容性就有保证。

## 原版

Minecraft 本身则不然，它的代码完全不必要将向后兼容性纳入考量。

首先，它不是一款 API ，不是插件或模组开发框架，本来就没有提供接口给任何人。所有方法都是 Minecraft 原版的开发者自己在使用。只要内部协商得当，怎么改架构都不会出现错误，遑论删除几个 public 方法了。

其次，Minecraft 原版的开发者也不会考虑新旧版本差异的问题。在原版开发者看来，游玩 1.16.5 版本的玩家，客户端必然是 1.16.5 版本的，不可能是 1.15.2 版本也不会是 1.14.4 版本，服务端更没有什么 ViaVersion ，没有什么工具能让运行着不同版本客户端的用户在同一个服务器里游玩。那么原版 Minecraft 的开发者根本不用担心旧版本代码能不能在新版本运行、新版本代码能不能被旧环境兼容等问题。这种问题只有在 API 和实现模块二者存在版本差异时才会出现。而在原版 Minecraft 的开发者眼里，当用户决定游玩某个版本的 Minecraft 时，服务端、客户端同处一个版本，不需要考虑版本差异。更何况客户端和服务端二者之间亦非 API 与实现模块的关系。

故此，只要开发者之间相互知会一声，Minecraft 中任何公共方法、架构都可以随意修改，上一个版本的方法，下一个版本可能改名，可能迁到另一位置，可能改变参数和返回值，也可能被删除。所以 Minecraft 源码本身不能从版本兼容性的视角加以衡量或评价。

虽然如此，在 Minecraft 相关开发领域，仍然需要考虑版本兼容性问题。假如以 1.16.4 版本的 Bukkit API 作为依赖进行插件开发，编译出的插件无法运行在 1.16.5 版本的服务端上，那么发行插件就显得很困难，必须为每个版本都单独编译 Jar ，乃至可能需要为每个版本编写不同的源代码。为了提高版本兼容性，插件开发框架与模组框架采用了两种不同的手段。

## 模组

对于模组框架而言，提高兼容性的手段主要是将模组代码依据中间表重混淆。假设原版中有某个方法在 1.13 下的 Notch 名为 `a` ，在 MCP 表中反混为 `getFoo` ，而在 1.14 被混淆为 `b` ，在 MCP 表中反混为 `getBar` 。尽管名字不同，但方法的各种属性，如参数、返回值等，乃至方法的含义和用处在这两个版本里都一致，那么可以为它在新旧两版本的中间表里分配同一个名字，比如 `func_123456_` 。依赖 1.13 版本的框架编写模组，可以调用 `getFoo` 方法。在编译时进行重混淆，则模组的字节码中不会有 `getFoo` ，只剩下了 `func_123456_` ，那么即使模组运行在 1.14 的服务端上，由于有中间表的存在，模组调用的是 `func_123456_` 方法，运行时有 `func_123456_` 方法，就不会抛出找不到方法的报错，至于 `getFoo` 或 `getBar` 这两个名字，在运行时毫无意义。然而，假如低版本的方法被删除，出现了架构的彻底修改，那么模组框架基本无法解决版本兼容性问题。

## 插件

Bukkit 则不然。 Bukkit 框架的实现模块与 API 分离。这一设计本身就确保了兼容性。几乎不会有模组是 1.7.10 - 1.18 全版本兼容的，但是理论全版本兼容的插件却屡见不鲜。这是因为 Bukkit 会不断修改 API 的实现模块，使得 Bukkit API 提供的方法在不同的版本里有近乎相同的功能，方法签名也不变。比如在 1.13 ，世界生成系统作了大改，但是 Bukkit API 中几乎毫无体现，这就是 API 稳定的力证。

Bukkit API 中，那些接口类（比如 `org.bukkit.entity.Player` 等）的实现并不是 NMS 中的类，而是所谓的 OBC 类。对于 Bukkit API 的使用者而言，只需要调用 API 中的方法即可。不需要关心具体实现是什么。这就好比某位插件开发者要给玩家发送一条消息，可以调用 `sendMessage` 方法，这对其摸索 Minecraft 数据包协议的能力、使用 Netty 等网络编程类库的能力、对于网络通信的憭解不会提出任何要求。但是 Bukkit 服务端的开发者就需要相应地使用 NMS 中的类和方法实现消息发送。很有可能就涉及到调用一些未被反混淆的方法，比如 `a` 或 `b` 等。

相应地，如果选择直接使用 NMS ，无异于直接调用 `a` 和 `b` 方法，版本兼容性很显然降低了。或许这两个方法在不同版本下的含义、作用完全相同，但混淆后名字的差异导致插件只能在开发时选择的版本上运行。如使用 1.13 的 NMS 开发插件，调用了 `a` 方法，到了 1.14 这个方法改名为 `b` ，那么插件就不能在 1.14 版本的服务端上运行了，因为无法找到对应方法。有一些情况下，小版本的改换也不兼容，如基于 1.16.4 版本的 NMS 写成的插件未必能在 1.16.5 版本的服务端上运行。

Bukkit 系列服务端没有 srg 那样的优质中间表。 NMS 里大多是版本不稳定的 Notch 名。插件开发者，应该尽可能选择调用 API 。Paper 项目维护者 Spottedleaf 曾表示，升级版本时，团队成员的大部分时间都花在应对混淆名改变上。上一个版本的 `a` 方法改名为 `b` 时，Paper 开发者也必须作出相应的调整，把对 `a` 方法的调用改名为对 `b` 方法的调用。不要小觑其工作量。前文已经提及，服务端是对 Minecraft 的源码作出修改。有成百上千处修改需要进行升级和维护。正是这些工作才使得 Bukkit API 的版本兼容性极强。而当 NMS 有在架构上的修改，比如将某个 `a` 方法彻底删除时，OBC 的代码也会被修改以便应对。模组开发者无法依靠框架开发团队的力量，只能自行应对修改，这就导致了模组很难具有较好的版本兼容性。

## 总结

Minecraft 不是用于插件或模组开发的框架，没有 API ，不能用「版本兼容性」来评价。为此，模组和插件框架的开发者们采用两种方式以提高版本兼容性。模组框架使用了中间表。插件框架则将架构分为三层，最底层为原版代码，即 NMS 。在其上是 OBC ，最上方是 Bukkit API 。Bukkit API 中的类基本都是接口，而 OBC 中的类基本都是具体的实现类。用户调用 Bukkit API 中的方法时只会接触到接口，不会接触到 OBC 中的类。在 OBC 中，有颇多对 NMS 中方法的调用，让用户不必直接操作 NMS 。每一次作版本升级时，插件框架的开发者都必须应对混淆名的变化，旷日持久，更要弥合 Minecraft 原版对于架构的大改，但这也成就了插件框架的版本兼容性。